<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, available online at https://engineering.purdue.edu/ece477/Course/Policies/policies.html

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<base href="https://reverseexoskeleton.github.io/Website/" />

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
            <h2>Progress Report for Isaac Hagedorn</h2>
            
            <!--<h4>Week 1:</h4>
            <b>Date:</b> -Enter today's date here-<br>
            <b>Total hours:</b> -Enter the number of hours you worked this week here-<br>
            <b>Description of design efforts:</b><br>
            -Discuss your design efforts here. Remember to follow the guidelines presented in the Progress Report Policy, available <a href="https://engineering.purdue.edu/ece477/Course/Policies/">here</a>. This is a template entry; simply copy/paste this entry when doing progress reports each week.</br>
	--!>
            <br>

		<h4>Week 2:</h4>
		<b>Date:</b> 9/3<br>
		<b>Total hours:</b> 10<br>
		<b>Description of design efforts:</b><br>
    	<br>This week I worked on standing up some basic testing environments/circuitry for Bluetooth testing as well as driver development testing on an STM32L0 microcontroller. 
	The goal for this week was to setup the development environment for the microcontroller and Bluetooth chip. 
	I worked first on setting up the testing environment for the microcontroller using LEDs to test my microcontroller drivers including initializing the GPIO registers, initializing the non-specific timer registers, and configuring individual pins for different modes. 
	I wrote the drivers with the intention of being able to easily bypass the low-level coding of bit operations and converting those into higher level functions. 
	I tested these drivers by setting up a simple LED circuit that toggled on and off LEDs with different timing initiatives if necessary. 
	Additionally, I completed writing drivers for setting up the ADC and SPI peripherals, but I have yet to begin testing for those.</br>
	<br><img src="Team/progress/ihagedorn/img/bluetooth.jpg" style="width:75%;height:50%;"></br>
	<br>
	For the Bluetooth testing, I setup a simple LED circuit, seen below, with an Arduino Uno that can turn on and off LEDS via wireless commands. 
	The incorporates an HC-05 which communicates with another Bluetooth device such as an Android phone to wirelessly transmit terminal commands.</br>
	<br>
	In addition to writing drivers and Bluetooth testing code, I also assisted in setting up the actual microcontroller development environment configurations in Eclipse and Github code repositories for the website, software code, and embedded software code. 
	During this time, I ran into several issues with the Eclipse environment and being able to flash the target device with built target over SWD. 
	The flashing of our microcontroller on a breakout board currently runs into an issue which results in unreliably flashing the device with about a 50 percent success rate while using the reset button. 
	The current theory is that this is a hardware issue with the breakout board, but further analysis will be needed to confirm this.</br>
</br>
	<br>
		<h4>Week 3:</h4>
		<b>Date:</b> 9/10<br>
		<b>Total hours:</b> 11 <br>
		<b>Description of design efforts:</b><br>
	<br>
	This week was a bit slow since I was wrapped up in several club events and other various commitments.
	After starting the drivers last week, I was able to finish drivers for using the ADC and PWM with the DevBoard. 
	These drivers are tested and ready for capability testing with actual components such as a stepper motor and potentiometer for frequency tests and proof-of-concept tests. 
	Additionally, I received our Bluetooth chip this week and spent a considerable amount of time on board bring-up and integrating it into my original test setup for the HC-05. 
	This included checking the different pins on the breakout board and interfacing with chip with AT commands.
	</br>
	<br>
	On our microchip, I worked on resolving a flashing issue. 
	I began my debugging adventure verifying various connections on the bread board and researching the SWD protocol with STM32. 
	After verifying that all the breadboard connections checked out and the soldering points looked solid under a microscope, I brought up a new software environment in eclipse and tested it with the DevBoard. 
	Eventually I discovered that the debug configurations for our original environment was linked to the wrong ELF file and there have been zero issues flashing the chip henceforth.
	</br>
	<br>
	In addition to embedded development, I also helped out with project component analysis and software overview for this week. 
	In the project component analysis, I provided research and analysis for the Bluetooth chip selection and microcontroller selection. 
	Additionally, I helped create a state machine diagram below for our state logic and provided further details of the microcontroller’s operations within the project.
	<br><img src="Team/progress/ihagedorn/img/State.png" style="width:65%;height:50%;"></br> 
	
</br>
	<br>
		<h4>Week 4:</h4>
		<b>Date: </b> 9/17<br>
		<b>Total hours: </b>15<br>
		<b>Description of design efforts: </b><br>
	<br>
	This week was mostly focused on setting up SPI, I2C, Bluetooth/UART, and testing. 
	I spent a majority of the week debugging the ZB7412-00 Bluetooth Low Energy chip since it didn’t seem to want to cooperate with my repeated attempts to interface with it over UART. 
	I have also tried re-flashing the chip with the production software using a provided SDK and IDE over J-Link; however, outside of the observed availability signals on the two JTAG pins, I can’t seem to get the chip to communicate. 
	Moving forward I’m looking to hookup every pin to a scope and recording its activity on power-up to see what is and isn’t happening. 
	<br>
	<br>
	Additionally, this week I worked on setting up the drivers and testing out the MCU’s SPI and I2C protocols in order to interface and command our IMU. 
	With the completion of these drivers I should be mostly finished with driver development and can move forward with creating header files along with integrating our pin mapping header file with these drivers. 
	I’m currently working on developing some SPI and I2C tests so that I can watch the signals over a scope and confirm their functionalities. 
	Additionally, I have been researching the commanding structure for the IMU so that I know what data to send it. 
	I currently have a detailed address mapping for for the IMU, but I have yet to come across how to command it using SPI.
	<br>
	<br>
	In addition to microcontroller development, I also assisted Matthew with making some of the Eschema schematic elements and future PCB footprints.
	I mostly made all the necessary components for the microcontroller environment.
	<br>
	<br>
	Finally, I worked on a macro test that integrated the drivers for the GPIOs, ADC, PWM, and timers into singular task, control the duty cycle of a LED using a potentiometer. 
	This setup is pictured below and can realistically control the frequency of the LED at a step size of about 0.7 mV as the potentiometer spans from 0 to 3 volts. 
	<br><img src="Team/progress/ihagedorn/img/breadboard.jpg" style="width:65%;height:50%;"></br>
	<br>
	On the non-technical side, I helped with the calculations for the different communication rates for the electrical overview and helped out on several bill of materials entries.
	<br>
	<br>
	Next week I hope to finalize SPI and I2C testing and resolve my Bluetooth development issue. 
	</br>
</br>
	<br>
		<h4>Week 5:</h4>
		<b>Date: </b> 9/24<br>
		<b>Total hours: </b>15<br>
		<b>Description of design efforts: </b><br>
	<br>
	This week was nothing glamorous or pretty. 
	It was mostly brute forcing code and debugging the results in order to understand what was going wrong with the Bluetooth and IMU interfacing.  
	At the start of the week we were working on talking to the Bluetooth chip over serial communication and talking to the IMU over SPI.  
	<br>
	<br>
	After working through multiple datasheets for the ZB7412-00 and not seeing any activity on any of the pins, I tested the current draw of the chip and found that the draw was 0 amperes. 
	As a result, we changed over to the RN4020 which I had previously interfaced with in weeks 2 and 3. 
	The interfacing of this chip over a serial connection can be seen in the figure below, and includes various ASCII commands to setup the chip, advertise, bond, and stand up the connection.
	<br><img src="Team/progress/ihagedorn/img/Serial1.jpg" style="width:65%;height:50%;"><br>
	<br>
	The second accomplishment of the week was interfacing with the IMU over SPI. After, once again, digging through multiple datasheets. 
	I was able to get the IMU to interface with an Arduino using a prebuilt library and one key assumption. 
	The assumption is that since the SPI pins share in common with the I2C pins that I have to use a similar commanding structure to I2C over the SPI lines in order for it to register mu commands.
	The results of this interface can be seen in the data output on the serial monitor below.
	I haven’t yet figured out the why this is the case, but I hope to make progress on this and commanding the IMU with the STM32 over the next week. 
	Additionally I hope, to begin integrating the analog event detector and other subsystems together next week or work with Zach on sensor fusion and Bluetooth packaging.
	<br><img src="Team/progress/ihagedorn/img/serial2.jpg" style="width:65%;height:50%;"><br>
</br>   
	<br>
		<h4>Week 6:</h4>
		<b>Date: </b> 10/1<br>
		<b>Total hours: </b>16<br>
		<b>Description of design efforts: </b><br>
	<br>
	This week, I was finally able to interface with each chip from the STM32. 
	After way too much time debugging, I was finally able to receive back the correct WHO_AM_I response from the IMJU pictured below. 
	I’m not completely sure what the actual issue was; rather, I kept addressing a series of possible issues until I was able to see the correct response. 
	The first issue I noticed was that the SPI was not acting as expected; rather, it was behaving like an I2C protocol with two data lines which responded at erratic times. 
	I resolved this issue by allowing my Arduino Due to talk with the chip and permanently setting several bits that disabled the I2C and persistently enabled the SPI lines. 
	The next issue I resolved was the polarity. 
	I had to set another bit in the configuration register in order to establish the polarity; otherwise I presume the polarity is in some undetermined state. 
	The last issue I noticed was the coupling of the NSS and MOSI lines. 
	To resolve this issue I realized that although the chip was grounded the lines still seemed to be floating, so I added an additional ground line and the lines seemed to finally separate. 
	<br><img src="Team/progress/ihagedorn/img/SPI_Scope.png" style="width:65%;height:50%;"><br>
	<br>
	While I was debugging the IMU interfacing, I also set up drivers for the UART peripheral in order to print out messages and values from the IMU. 
	This peripheral will be used with the BLE chip to command it. 
	Later in the week, I was able to use the UART to configure the RN-4020 which is our new BLE chip after having several unresolvable issues with the ZB7412. 
	I am able to configure the chip properly and connect; however, I sporadically lose connection and I’m still figuring out how to pack floats into packets to put in the air. 
	<br>
	<br>
	Lastly, I worked on starting the software formalization for next week. 
	This week I worked on collecting information for all of our third-party software libraries and laying out our testing plan for each chip and unti testing for the drivers. 
	I believe that most of testing will surround the IMU data collection and BLE dropped connection handling.<br>
</br>
	<br>
		<h4>Week 7:</h4>
		<b>Date: </b> 10/8<br>
		<b>Total hours: </b> 20<br>
		<b>Description of design efforts: </b><br>
	<br>
	This week was fast paced with a lot of great progress toward laying out the full product on the breadboard. 
	At the end of this week, I had three major achievements: Software Formalization/Planning, Completing the breadboard layout, and sending packets over Bluetooth between two chips.
	<br>
	<br>
	This accomplishment of the week was the Bluetooth communication between two BLE chips (One in central mode and one in peripheral mode). 
	This is a big step toward communicating with the computer over Bluetooth since both ends were being commanded by an MCU for now. 
	The issue I learned was that the RN4020 BLE chip required an extra hardware signal to flip it into the MLDP mode and begin transmitting and receiving data as opposed to CMD mode which allows the user to configure the chip
	This revelation allowed me to communicate between an Arduino and the STM with two BLE chips in-between.
	<br>
	<br>
	The second accomplishment of the week was the completion of the breadboard layout with the corresponding code for individual portions of the project. 
	I was finally able to layout all the ICs, potentiometer, and LEDs on one board and test portions separately pictured below.
	This step also allowed me to finish the pinout description for the STM, pictured below, which needed to be finalized for the PCB.
	The next step will be integrating each portion together and ensuring nothing breaks. 
	<br><img src="Team/progress/ihagedorn/img/breadboard2.jpg" style="width:65%;height:50%;"><br>
	<br><img src="Team/progress/ihagedorn/img/pinout.png" style="width:65%;height:50%;"><br>
	<br>
	The third accomplishment of the week was making the necessary traces for the Data Aquisitions DaQs PCB.
	I assisted Matthew and Swag with figuring out the optimal pin connects as well as layout for the board to neatly situate each chip and also optimize test points for the board bring-up process.
	<br>
	<br>
	The last achievement of the week was the Software Formalization and Planning.
	I feel very comfortable with the testing plan that I laid out for each portion of the project and the development yet to come.
	Additionally, within this document I characterized each software component, its role, and plans for development internally/externally. 
	<br>
	<br>
	Next week is Fall Break and design reviews and I will look to work on preparing for that along with continuing development on packet structures and improving communication for Bluetooth.
 <br>
 	<br>
		<h4>Week 9: </h4>
		<b>Date: </b> 10/22<br>
		<b>Total hours: </b> 12<br>
		<b>Description of design efforts: </b><br>
	<br>
	These past couple weeks our team successfully completed the design review and placed our order for our PCBs. 
	In addition to helping with PCB planning and finalization/verification, I also worked on integrating some of the larger chunks of the project together including working out the timing operations for our timer interrupts with sampling values and coordinating communication as well as general interrupts for reading and writing using DMA. 
	In addition to this development, I finalized integrated testing on my end of sampling the IMU over SPI, transmitting the data over UART to the BLE chip and outputting the data over the air to another BLE chip in order to simulate over the air transmission of IMU data to the host computer. 
	I now need to work on a reliable connection between the host computer and the BLE chip as well as continuing development of the Bluetooth packet structures with Zach.
	Currently the BLE chip is able to reliably advertise itself to similar BLE chips, but there are issues with reliably finding the advertising device on a PC and establishing a connection that does not falter. 
	Our current discussion of the packet structure is best summarized by the image below with the idea of moving all possible data processing over to the host computer and only collecting raw data on the MCU. 
	<br><img src="Team/progress/ihagedorn/img/packet.png" style="width:65%;height:50%;"><br>
     	<br>
	In addition to continuing BLE development with Zach, I anticipate that next week I will also be qorking with Swag and Matthew to test the haptic feedback capabilities and begin training our ADC and PWM tables with realistic values.
	Currently the ADC and PWM periphreals have verified functions for reading values from the ADC and creating a feedback loop that updates the PWM via DMA. 
	This configuration will need to be altered to more closely allign with the final intended design.
<br>    
	<br>
                <h4>Week 10: </h4>
                <b>Date: </b> 10/29<br>
                <b>Total hours: </b> 19<br>
                <b>Description of design efforts: </b><br>
        <br>

	This week I finished the timer and interrupts integration for sampling the IMU and ADC and configuring the PWM. 
	The code is configurable to adjust the frequency of sampling and frequency of adjusting the PWM for further testing and profiling of the affects each frequency has on the system as a whole. 
	I also still need to figure out the correct priorities for each of the interrupts in order to prevent interrupts from bringing down the entire system. 
	<br>
	<br>
	In conjunction the finalized development of the timer configuration and interrupt code, Zach and I were finally able to setup testing for communication between the BLE chip and host computer. 
	This breakthrough included finally resolving the discoverability issue and setting up a service with characteristics for a subscriber to read and write from. 
	The discoverability issue we found out had to do with the name of the device being too long for its advertisement packet which caused frequent drops in advertisement. 
	This is a really weird error because even the factory default name is too long and causes issues. 
	<br>
	<br><img src="Team/progress/ihagedorn/img/BLE_trans.png" style="width:85%;height:115%;"><br>
	Image of communication between host and MCU
	<br>
	<br>
	Now that Zach and I are finally able to connect and communicate, we attempted to start integration testing between our two systems, my sampling and data delivery with his data collection and processing, to see if we could recreate what Zach had been doing with the Arduino and Unity in weeks prior. 
	However, we seem to be having some issues with packaging the data correctly before transmission so that Zach receives the values in the correct format.
	<br>
	<br>
	After we finish this integrated test, we will still need to work on data transmission in the reverse direction and finally configuring our lookup tables for the DMA to find intelligent values instead of converting and ADC percentage. 
<br>
	 <br>
                <h4>Week 11: </h4>
                <b>Date: </b> 11/5<br>
                <b>Total hours: </b> 14<br>
                <b>Description of design efforts: </b><br>
        <br>
	
	This week was a heavy amount of integration and testing on the fully populated PCB, pictured below. 
	Over the course of the week, I worked on testing out the power operations, programming headers, soldering testing points, and confirming induvial chip operations on the PCB. 
	This testing included ensuring communication between the MCU and IMU, ensuring the boot sequence operation on the BLE chip, polling values from the ADC to graph through Arduino, and generating PWM signals. 
	All in all, we were able to achieve three of the tasks of the system bring up and are close to achieving the fourth.
	<br><img src="Team/progress/ihagedorn/img/PCB1.jpg" style="width:50%;height:65%;"><br>
	<img src="Team/progress/ihagedorn/img/PCB2.jpg" style="width:50%;height:65%;"><br>
	<br>
	The first task I achieved was communication with the IMU. 
	For this I first had to configure the IMU chip for SPI mode over I2C and then tapped into the 4 SPI lines to watch how the chips handled a simple who_am_I request. 
	After observing the correct oscilloscope behaviors, I tapped into the UART lines from the MCU and polled IMU data to be printed over UART to an Arduino serial plotter. 
	<br>
	<br>
	The second task I achieved was generating a PWM signal of varying duty cycles that controlled the haptic feedback circuit. 
	This was just a matter of transferring over the code from the dev board and ensuring that signal was as expected on the oscilloscope before hooking up the sensitive haptic feedback circuit. 
	<br>
	<br>
	The third task I achieved was reading ADC values from the potentiometer and mapping the data over UART to an Arduino serial plotter similar to task one. 
	With this third task complete we should have completed three of our preliminary PSSCs and are ready to start introducing timing and power consumption efficiency into the equation.
	<br>
	<br>
	The fourth task which is still to be completed over the weekend is confirming that boot sequence is received correctly by the BLE chip and the configurations are correct on the chip.
<br>
	<br>
	<h4>Week 12: </h4>
	<b>Date: </b> 11/12<br>
	<b>Total hours: </b> 17<br>
	<b>Description of design efforts: </b><br>
	<br>
	This past week we achieved several checkoffs including sampling the ADC and mapping values to an angle (pictured below), generating a PWM signal at varying frequencies to generate haptic feedback, and communicating with the IMU over SPI and graphing the data in a serial plotter. 
	With these three PSSCs complete, I was ready to begin packaging the sampling of the IMU and ADC into a single interrupt function that is controllable at a specific frequency. 
	In addition to packaging this data, I also worked on integrating DMA transfers into these functions in order to speed up data processing and remove unnecessary overhead associated with accessing registers and flags. 
	However, as a result of integrating the DMA into the project I also created a few headaches of my own with handling the interrupts associated with moving the data around.
	<br><img src="Team/progress/ihagedorn/img/Setup.png" style="width:50%;height:65%;"><br>
	<br>
	On the communication end of the project, I worked on redeveloping the UART communication and commanding of the BLE chip from polling commands to interrupts in order to improve the timing and provide an error handling functionality for the Bluetooth during its initialization cycle in case of bad transfers. 
	This included converting all transmits to interrupts that callback at the end of the transfer and start-up a receive interrupt whose callback contains error processing and handling based on the feedback for the BLE commands. 
	Additionally, this interrupts will serve the project in another capacity when the BLE chip is in MLDP mode in order to more efficiently handle the buffers and communication between the host computer. 
	<br>
	<br>
	Finally, I worked on reading through some of Zach’s development so that I may step into his role if necessary and continue joint development between the MCU and host computer.
<br>
	 <br>
                <h4>Week 13: </h4>
                <b>Date: </b> 11/19<br>
                <b>Total hours: </b> 18<br>
                <b>Description of design efforts: </b><br>
        <br>
	This last week our team faced several adversities due to illnesses, but we were still able to overcome and get another checkoff for our new PSSC of waking the MCU after a stimulating event to the system. 
	With this checkoff complete, our last check preliminary checkoff is the Bluetooth communication. 
	<br>
	<br>
	To achieve our fourth checkoff, we utilized the previously populated HBmS and an analog event detector which uses filtering addition and subtraction to generate a digital signal for any transient change in the analog value from a potentiometer. 
	This digital signal was then used as a system wakeup interrupt after the system is put to sleep. 
	Additionally, the interrupt was used to put the system to sleep after an interrupt is not detected for a certain number of cycles. 
	<br>
	<br>
	Over the course of the week, I worked with Zach to hash out the Bluetooth communication structure (pictured below) and test Bluetooth communication driven by the MCU. 
	The structure is quite simple; the RN4020 will serve as the server which hosts the memory space for exchange of data between the MCU and host computer. 
	The MCU writes to one characteristic and reads data from another, each under the same service. 
	On the other side, the host computer reads from the first characteristic and writes to the other. 
	This setup allows the MCU to control the data flow. 
	As the sole data manager, the MCU can keep the data stored on the server up to date much faster than the host computer could. 
	<br><img src="Team/progress/ihagedorn/img/bluetooth_struct.png" style="width:50%;height:65%;"><br>
<br>
	 <br>
                <h4>Week 14: </h4>
                <b>Date: </b> 11/28<br>
                <b>Total hours: </b> 8<br>
                <b>Description of design efforts: </b><br>
        <br>
	This week was shortened by thanksgiving break; however, I did work on developing the dip switch functionality of the embedded software in order to quickly change modes for testing purposes of the separate MCU functionalities such as the SPI/IMU communication, PWM, ADC, or UART/BLE communication. 
	This was a simple digital decoding software for the various modes and conditional structure based on the decoded value. 
	In addition, to the dip switch functionality, I also finally began testing on the final packaged design thanks to Matthew’s prototyping over the break (pictured below). 
	Of the final firmware code, I tested the packaged sampling function (IMU and ADC) with interrupts, the Bluetooth advertisements, and the system wakeup. 
	Over the course of the next week, I hope to finalize integration testing with Zach and to begin checking off our final PSSCs for the final product.
	<br><img src="Team/progress/ihagedorn/img/Final.jpg" style="width:50%;height:65%;"><br>
<br>
	 <br>
                <h4>Week 15: </h4>
                <b>Date: </b> 12/5<br>
                <b>Total hours: </b> 23<br>
                <b>Description of design efforts: </b><br>
        <br>
	This past week was mostly integration testing with the host computer and integration testing for the sleep/wake functionality. 
	<br>
	<br>
	Additionally, I worked modifying the haptic feedback updating functions and the Bluetooth error handling abilities. 
	Before the week started we were able to inconsistently communicate with the host software. 
	As a result, we decided to add more reliability on the MCU side in order to help isolate any issues. 
	Therefore, we setup an interrupt based boot sequence for the BLE chip and communication to ensure the data sent over the line to the RN4020 is always consistently available. 
	This update included overhauling the initialization functions and receiving framework for the MCU. 
	Additionally, we worked developing a new characteristic to indicate the status of the RevEx device to the host computer i.e. awake or asleep. 
	<br>
	<br>
	Next, I worked on integrating the sleep and wake functions into the main interrupt structure in order to put the device to sleep when motion is no longer detected via the ADC or IMU and wake upon a system interrupt from the elbow joint. 
	Additionally, I modified the haptic feedback functionality to be more streamline in calculating and adjusting the PWM frequency and duty cycle. 
	We decided to take this route instead of creating tables for design simplicity. 
	<br>
	<br>
	Finally, this week we successfully demoed the final PSSCs to course staff and were able to demonstrate all functions properly. We will continue development as we prepare for the Spark challenge. 
	These improvements include adding the DMA to UART transfers, adding reliability to the sleep function, reducing power consumption, and slimming down unnecessary code.  
	<br><img src="Team/progress/ihagedorn/img/teamPhoto.jpg" style="width:50%;height:65%;"><br>
        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
