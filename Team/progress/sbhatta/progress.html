<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, available online at https://engineering.purdue.edu/ece477/Course/Policies/policies.html

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<base href="https://engineering.purdue.edu/477grp6/" />

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
        <div id="content">
            <h2>Progress Report for Swagat Bhattacharyya</h2>

            <h4>Week 2:</h4>
            <b>Date:</b> 08/27/2021<br />
            <b>Total hours:</b> 20<br />
            <b>Description of design efforts:</b><br />
            I spent this week working on theory, breadboard-level design of the hardware subsystems, and experimental validation. Additionally, I contributed the “Theory of Operation”
            section to the Functional Specification deliverable. The benchtop setup for the experiments detailed below is shown in Fig. 1.

            <p></p>
            <img src="Team/progress/sbhatta/img/week2/bench_setup.png" width="50%" /></img>
            <figcaption>Fig. 1: Bench and breadboard setup for week 2 experiments.</figcaption><br />

            The following summarizes my progress on each hardware subsystem:

            <ul>
                <li>
                    <b>Microcontroller</b><br />
                    For prototyping, I had ordered some STM32L081KZT6 chips and set one up on
                    a breadboard this week. We were able to toggle a GPIO pin on the chip; however, we are
                    currently facing issues reliably programming the microcontroller. The IDE error message
                    essentially states either: (i) device not recognized or (ii) failed to reset device. We are not sure if
                    this is truly a hardware issue or an issue with our IDE configuration. When we were able to
                    program the microcontroller, the reset button needed to be manually asserted just before the
                    program is uploaded. We are now checking if our IDE configuration works on a development
                    board (we are having issues with this as well). Additionally, Zach found out that we need to
                    perform floating point computation on the wearable (we initially thought this would not be
                    necessary); hence, we are now looking at the STM32L4 series. Unfortunately, these chips are
                    only available in difficult-to-solder footprints due to the current chip shortage
                    <a href="https://www.digikey.com/en/products/filter/embedded-microcontrollers/685?s=N4IgjCBcoLQCxVAYygMwIYBsDOBTANCAPZQDaIcAnGAGyUgC6hADgC5QggC%2BhMATIhApIrAE4BXAsTIgArIy485g5lDAtVkPrMVA">STM32L4 Link</a>
                </li>
                <li>
                    <b>IMU</b><br />
                    We are waiting on a breakout board submitted to JLCPCB for our IMU, the BHI160B. This
                    IMU is low-power, high-precision, can operate at 1.8 V, and can sample at the needed rate. But
                    most importantly, it is in stock (we brought several), unlike many other IMU chips. After setup,
                    we can use this chip to test long-distance I2C functionality.
                </li>
                <li>
                    <b>Haptic Feedback and Regenerative Braking</b><br />
                    This is one of the most innovative aspects of our
                    project. Haptic feedback generated in the VR simulation (Eg. because of a collision in a VR
                    simulation) is mapped to a “duty cycle” and transmitted to the wearable via BLE. This “duty
                    cycle” is modulates the mean latch time of low-power solid-state relays. These relays will short
                    the coils of a motor connected to the elbow joint via a gear reduction system. When the coils of
                    a permanent magnet motor are shorted, the motor can act as an electronically-controlled rotary
                    dashpot; this dampening effect is leveraged to deliver haptic feedback to the user. For a bipolar
                    stepper motor, it can be mathematically shown that the greatest damping is achieved by
                    separately shorting the phases (uses two relays), rather than connecting the phases in series and
                    then shorting them (uses one relay). The braking torque generated by a bipolar stepper motor
                    (the derivation is based off state equations given in
                    <a href="https://ieeexplore.ieee.org/document/70170">https://ieeexplore.ieee.org/document/70170</a>)
                    when the coils are shorted with duty cycle 𝐷 is given in the Laplace Domain by:
                    <img src="Team/progress/sbhatta/img/week2/motor_eqn.png" width="85%" /></img>
                    <p></p>
                    To experimentally characterize the viscous coefficient as a function of duty cycle, a test setup
                    was created (more details can be found in Matthew’s report). The setup consisted of a pulley
                    and a flywheel. A small mass is suspended on a string that goes over the pulley and terminates
                    at the flywheel. The flywheel is connected to a bipolar stepper motor and an optical encoder.
                    The experiment consisted of dropping the fixed mass for varying relay duty cycles and
                    measuring the optical encoder output as the flywheel rotates. The mass is chosen such that the
                    angular rate quickly approaches a terminal rate as shown in Fig 2.
                    <img src="Team/progress/sbhatta/img/week2/angular_rate.png" width="60%" /></img>
                    <figcaption>Fig. 2: Experimental measurement of Angular Rate vs. Time for varying relay duty cycles.</figcaption><br />
                    The terminal rate for each duty cycle is computed by averaging the last 0.25 s of the
                    corresponding angular rate data. The terminal rate is related to the viscous coefficient by:
                    <img src="Team/progress/sbhatta/img/week2/viscous_coeff.png" width="85%" /></img>
                    <p></p>
                    Fig. 3 shows the terminal angular rate and viscous coefficient versus relay duty cycle for our
                    stepper motor. Our experiment suggests that the viscous coefficient can be modulated over an
                    order of magnitude (the required damping can be obtained using a gear reduction system).
                    <p></p>
                    <img src="Team/progress/sbhatta/img/week2/duty_torque.png" width="60%" /></img>
                    <figcaption>Fig. 3: Terminal angular rate and viscous coefficient vs. relay duty cycle</figcaption><br />
                </li>
                <li>
                    <b>Power Measurement</b><br />
                    We have wired high-efficiency 1.8 V and 0.9 V regulators (ADP150 and
                    ISL21080DIH309Z) for our project. Power measurements are performed by via current shunt:
                    the voltage drop across a 0.1 Ohm resistor connected between the power supply and
                    breadboard is amplified by an INA121 instrumentation amplifier to precisely measure the
                    instantaneous power draw of our system. Given this setup, the Power Draw of our system (W) is
                    0.07385*V_Corrected, where V_Corrected is the offset-corrected INA121 output voltage (V).
                </li>
                <li>
                    <b>Analog Filterbank and Event Detector</b><br />
                    This has been a large time commitment for the last
                    week. This circuit, shown in Fig. 4, behaves differently in simulation and reality. The filterbank
                    and event detector are used for ADC antialiasing and as a wakeup interrupt for the
                    microcontroller, respectively.
                    <p></p>
                    <img src="Team/progress/sbhatta/img/week2/analog_filter.png" width="85%" /></img>
                    <figcaption>Fig. 4: Overall schematic of the analog filterbank and event detector</figcaption><br />
                    <img src="Team/progress/sbhatta/img/week2/differentiator_designs.png" width="40%" /></img>
                    <figcaption>Fig. 5: Standard robust differentiator</figcaption><br />
                </li>
                The general working principle of the event detector is as follows:
                <ol>
                    <li>
                        There are two analog input channels, each of which feeds into a differentiator circuit
                        (which outputs a voltage depending on the rate of change of the input signal).
                    </li>
                    <li>
                        Differentiator voltages are converted to currents, and the positive and negative
                        currents are summed separately. The (nonlinear) V-I conversion is done passively via
                        BAT54s diodes which have all terminals maintained at an equilibrium voltage of midrail
                        (0.9 V) via negative feedback control.
                    </li>
                    <li>
                        The summed currents are converted back to voltages and subtracted, yielding an
                        always-positive signal that can be thresholded to indicate if one of the analog input
                        channels contains a transient signal. Transient signals indicate a potentially interesting
                        event and can be used to wake the microcontroller from sleep.
                    </li>
                </ol>
                The design I used this week used the circuit shown in Fig. 5. However, I am having severe issues tuning
                the sensitivity of the differentiator (I am not able to get a robust tuning that is neither insensitive nor
                hypersensitive). Nevertheless, the analog event detector currently draws 0.72 mW and has a trigger
                latency of 5 ms.
            </ul>

            <!-- Week 3 -->
            <h4>Week 3:</h4>
            <b>Date:</b> 09/05/2021<br />
            <b>Total hours:</b> 10 hours<br />
            <b>Description of design efforts:</b><br />
            In week 3, I helped with the component analysis (“energy harvesting chip,” “IMU,” and “battery” sections). I
            ordered some breakout boards for the LSM20948, which is our new 9 DOF IMU. Due to the chip shortage, we will need
            to desolder the IMU chips from the breakout board. We made tis change because we realized that that a 9
            degree-of-freedom (DOF) IMU was physically necessary for accurate angle estimation (previously, we thought a 6-DOF
            sensor would suffice if we leveraged some clever mathematics). The BHI160B (our old IMU) could be connected to an
            external magnetometer since it has a sensor fusion core; however, the recommended magnetometer (BMM150) is in a
            dense BGA package, which would not be easy to solder. Nevertheless, my main R&D tasks this week were working on the
            haptic feedback system and meeting with Prof. Hong Tan (alongside Matthew). Our solid-state relays arrived this week,
            so we redid our haptic feedback torque tests (our experiment last week used mechanical relays). Fig. 6 shows a
            schematic of our haptic feedback generation circuit, which draws 2 mW (maximum at 100% duty cycle).

            <img src="Team/progress/sbhatta/img/week3/haptic_schematic.png" width="50%" /></img>
            <figcaption>Fig. 6: Schematic of the haptic feedback generation circuit.</figcaption>

            <br />
            The CPC1020 optoelectronic relay was current-starved to lower power draw, which decreased the switching speed of the
            relay. We measured the switching speed by using the relay with a pullup resistor in a voltage divider configuration
            such that the voltage divider output drops when the relay is activated (see Fig. 7 on Matthew’s updates). The turn-on
            and turn-off time of the relay given our configuration were roughly 9 ms and 0.5 ms, respectively. This limits the PWM
            frequency and duty cycles that can be used in our design. The data collected with this setup are presented in Fig. 7
            and Fig. 8. Compared to last week, we observed significantly more linearity in the viscous coefficient (as a function
            of duty cycle), which agrees well with our theoretical model. The saturation in the viscous coefficient at low duty cycles
            is due to the limitation in the relay switching speed. The torques generated by the motor can be amplified via a gear
            reduction system. Since the motor torque also implicitly depends on the motor shaft angular rate, it can be shown that
            the torque felt by the user scales as the square of the gear reduction ratio.

            <img src="Team/progress/sbhatta/img/week3/angular_rate_v_time.png" width="50%" /></img>
            <figcaption>Fig. 7: Measurement of Angular Rate vs. Time for varying relay duty cycles (10 Hz relay frequency).</figcaption>

            <img src="Team/progress/sbhatta/img/week3/terminal_angular_rate.png" width="50%" /></img>
            <figcaption>Fig. 8: Terminal angular rate and viscous coefficient vs. relay duty cycle (10 Hz relay frequency).</figcaption>

            <br />
            Our meeting with Dr. Tan was extremely helpful. Matthew realized after our tests that stopping the user’s arm would be
            impractical and uncomfortable due to mechanical (mounting) considerations. Dr. Tan suggested that we produce an oscillatory
            torque (which we have already demonstrated – see Matthew’s updates) to give the sensation of feedback/resistance. There are
            several merits of this approach as compared to force-feedback; force-feedback systems may “fight” with the user’s intentions,
            producing discomfort, and they are usually more difficult to control. We are planning to collect linear acceleration data
            (to measure the vibration) so that Dr. Tan can give us some more insight as to how a user would perceive the input.

            <!-- Week 4 -->
            <h4>Week 4:</h4>
            <b>Date:</b> 09/10/2021<br />
            <b>Total hours:</b> 20 hours<br />
            <b>Description of design efforts:</b><br />
            In week 4, I wrote the electrical overview document and helped with the BOM. Matthew and Zach particularly helped my efforts by
            making a schematic library and aiding with digitization of hand-drawn signal flow diagrams, respectively. In terms of design efforts,
            I spent most of the week working on the `analog event detector’.
            There were several issues preventing proper functionality like severe power line noise and poor solder joints, which were
            eventually fixed. Tuesday, I managed to get my event detector design working somewhat, yet I scrapped my designs for this
            circuit and began anew. I made this decision because I subscribe to Taguchi’s philosophy on design
            (<a href="https://scialert.net/fulltext/?doi=ajsr.2013.27.37">https://scialert.net/fulltext/?doi=ajsr.2013.27.37</a>).
            Essentially, my design was sensitive to electrical noise (due to the differentiator circuit) and component parametric
            variation (due to capacitors and especially Schottky diodes not being well-matched). I could spend days tuning component
            tolerances; however, there would be no guarantee that I could compensate for an inferior circuit topology. My new
            single-channel event detector design is shown in Fig. 9.
            <p></p>
            <img src="Team/progress/sbhatta/img/week4/NewEventDet.png" width="100%" /></img>
            <figcaption>Fig. 9: Schematic of the redesigned analog filterbank and event detector.</figcaption>
            <br />

            The circuit in Fig. 9 uses a passive lowpass filter and a differential amplifier to create a highpass filter with gain;
            this topology offers guaranteed closed-loop stability even at high filter gains (my old design had issues with this).
            The transfer function of this circuit is given by:
            <img src="Team/progress/sbhatta/img/week4/HPFTransfer.png" width="50%" /></img>
            <p></p>
            The highpass filter output rises above or falls below midrail if there is a positive or negative signal transient, respectively.
            Hence, the highpass filter output is passed to two comparators, to determine if there is a signal transient. The comparator thresholds
            generated via the forward voltage drop of two matched Schottky diodes. The comparator outputs are passed to an OR gate to generate the
            wakeup for the microcontroller (I have not implemented the OR gate yet). Fig. 10 shows the analog event detector responding to an event
            (i.e. a signal transient).
            <p></p>
            <img src="Team/progress/sbhatta/img/week4/EventDetResp.png" width="60%" /></img>
            <figcaption>Fig. 10: Analog event detector responding to a signal transient (red trace) from a potentiometer. The highpass filter output (yellow trace) and comparator outputs (green and blue traces) are also shown.</figcaption>
            <br />

            This analog event detector was measured to have a typical detection latency of 3 ms and a maximum power draw of 1.1 mW. For comparison,
            the measured power draw of the haptic feedback circuit is 2.2 mW (maximum). Note that the stated power figures account for the 49% efficiency
            of our LDOs. I have two remaining hardware design tasks: the battery management system and the long-range I2C communication bus. After talking
            to Dr. Tan, we realized that we needed to accuracy determine the vibration felt by the user when haptic feedback is being applied. This vibration
            would be greatly determined by the gear ratio. Hence, I simulated the vibration felt by the user in MATLAB by numerically solving a nonlinear second
            order ODE. It was found that a 10:1 gear ratio would offer sufficient vibration during braking (simulation results are shown in Fig. 11).
            <p></p>
            <img src="Team/progress/sbhatta/img/week4/HapticsSim.png" width="60%" /></img>
            <figcaption>Fig. 11: Simulation of the net acceleration felt by an IMU on the user’s palm and the arm rotation rate if a 50% PWM signal (at 10 Hz) is applied to the optoelectronic relays, and the user applies a constant torque of 1 N*m about their elbow joint.</figcaption>
            <br />

            <!-- Week 5 -->
            <h4>Week 5:</h4>
            <b>Date:</b> 09/24/2021<br />
            <b>Total hours:</b> 12 hours<br />
            <b>Description of design efforts:</b><br />
            In week 5, I helped Matthew with the PCB organization figure in the mechanical overview. However, the vast majority of my design efforts were aimed toward
            constructing and characterizing our system for harvesting energy from the back-emf of the stepper motor. I also made some restrictions that simplified the
            power management system hardware design. The two main hardware simplifications I made were:
            <ol>
                <li>
                    The battery can only charge via USB when the wearable is powered off. When the wearable is on, the battery charges via the energy harvesting circuit.
                    This helps because the on-off switch (a DPDT switch) can also be used to toggle the battery charging source.
                </li>
                <li>
                    The energy harvesting circuit feeds directly to a boost converter, which in turn feeds to the battery charging circuit. This method is much less efficient
                    than the method proposed in the (original) “Electrical Overview” document; however, it is significantly simpler and more reliable.
                </li>
            </ol>
            On Wednesday, I was unable to get our energy harvesting chip to work, and I was unable to understand why it was not working since the chip was a “black box.”
            I was gently cautioned that I have very little time for prototyping; hence, I scrapped my previous energy harvesting circuit design and began anew.  I began my
            design with a standard Schottky diode bridge rectifier, output capacitor, and boost converter. Joe and I realized that the diodes in the bridge rectifier were leaky,
            causing the voltage on the storage capacitor to decay rapidly (Fig. 12).

            <p></p>
            <img src="Team/progress/sbhatta/img/week5/Leakage.png" width="60%" /></img>
            <figcaption>Fig. 12: Harvesting energy with a Schottky diode bridge rectifier. The stored charge on the capacitor leaks at a rate of roughly 4 uA.</figcaption>
            <br />

            I tried swapping out the BAT54s diodes I was using for 1N5819, but that did not help. If I added an extra Schottky diode after the bridge rectifier, the effective
            dropout voltage would increase (the back-emf of the stepper motor is already a low voltage). Hence, I needed an ideal diode to block the bridge leakage current.
            I created an ideal diode by using a BJT and a low-power instrumentation amplifier (unfortunately, there are no commercially-available ideal diode chips that work at
            such low voltages). The schematic of our energy harvesting circuit is shown in Fig. 13.

            <p></p>
            <img src="Team/progress/sbhatta/img/week5/EnergyHarvestingSch.png" width="90%" /></img>
            <figcaption>Fig. 13: Schematic of the energy harvesting circuit.</figcaption>
            <br />

            When not in use, the instrumentation amplifier in the ideal diode (which draws 100 uW) can be shut off via a power-gating transistor (this is a future revision).
            Fig. 14 shows a demonstration of energy harvesting by dropping a 100 g mass off our test rig. The demonstration in Fig. 14 harvested 9.1 mJ of usable energy
            (measured via a 10 kOhm load at the 5 V boost converter output) from 1.32 J of gravitational potential energy, meaning our conversion efficiency is 0.7%. Although
            this efficiency sounds bad, it is a few times higher than state-of-the-art piezoelectric harvesting systems
            (<a href="https://www.researchgate.net/figure/Energy-conversion-efficiency-of-various-types-of-piezoelectric-raindrop-kinetic-energy_tbl3_309426746">https://www.researchgate.net/figure/Energy-conversion-efficiency-of-various-types-of-piezoelectric-raindrop-kinetic-energy_tbl3_309426746</a>) and adequate for a proof
            of concept especially given the constraint that the energy harvesting circuit should not interfere with the operation of the haptic feedback system.  My remaining
            design tasks are to: (1) Check if HBmS circuits work with MOSFETs (2) draw the schematics & PCBs for our boards and (3) order a new batch of parts.
            <p></p>
            <img src="Team/progress/sbhatta/img/week5/Efficiency.png" width="60%" /></img>
            <figcaption>Fig. 14: Method/demonstration of determining energy harvesting efficiency by dropping a mass. Yellow: Storage capacitor voltage, Green: 5 V Boost converter output, Blue: Ideal diode activation.</figcaption>
            <br />

            <!-- Week 6 -->
            <h4>Week 6:</h4>
            <b>Date:</b> 09/30/2021<br />
            <b>Total hours:</b> 15 hours<br />
            <b>Description of design efforts:</b><br />
            In week 5, I worked on finalizing the schematic and layout for the Haptics and Battery-management System (HBmS) with Matthew. Essentially, I did the schematic, Matthew did most of the layout/routing, and we both made fine-adjustments to the PCB.
            The schematic of the HBmS is shown in Fig. 15. This was the simpler of our two boards, so we sent it to JLC-PCB for fabrication after we performed an internal design review. We seek to have the HBmS board tested and characterized (to a moderate level of rigor)
            by the end of week 8. We made two simplifications that were tested on a breadboard: (i) we replaced the two BJTs in our haptics system with one low-threshold nMOS transistor and (ii) we removed the ideal diode subcircuit, which mitigates charge leakage from the
            supercapacitors on the energy harvesting circuit. There are three leakage major charge mechanisms: (i) “backflow” through the bridge rectifier (~4 uA), (ii) capacitor self-discharge (~5 uA), and (iii) boost converter input leakage current (~1 uA). It turns out
            that the amount of charge leakage the ideal diode would be preventing in the energy harvesting system dwarfs the current draw of the ideal diode (~40 uA), and it is simply not worth allocating microcontroller clock cycles toward micromanaging the power draw of
            the ideal diode. Our crude energy harvesting system still performs well, but the storage capacitor size must be selected carefully to ensure that it fully-charges above the boost-converter on-threshold during an average elbow motion while storing appreciable energy.
            The only HBmS circuit not tested on the breadboard is the LiPo battery charging circuit (which I got from the application notes on the PMIC datasheet). We plan to have the DAqS schematics completed and parts ordered by this weekend. Additionally, by the end of next
            week, we need to test that we can reliably: (i) program our barebones microcontroller running on a 1.8 V supply rail and (ii) communicate with our Bluetooth module with 1.8 V logic (the datasheet says the module can operate at 1.8 V, it but recommends 3.3 V as the operating voltage).

            <p></p>
            <img src="Team/progress/sbhatta/img/week6/HBmS.png" width="100%" /></img>
            <figcaption>Fig. 15: Schematic of the Haptics and Battery-management System (HBmS) [V1.0].</figcaption>
            <br />

            <!-- Week 7 -->
            <h4>Week 7:</h4>
            <b>Date:</b> 10/08/2021<br />
            <b>Total hours:</b> 10 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I worked on finalizing the schematic for the DAqS with Isaac. The completed schematic for the DAqS
            is shown in Figure 16. Together we confirmed that the MCU pinmap would support the required functionality
            (ADC, UART, SPI, I2C, Wakeup Interrupt). We also confirmed the Bluetooth and MCU pinmap. We changed the
            pinmap once during the week because of a discovery Isaac made during prototyping with the bluetooth module.
            Unfortunately, Matthew had already finished the PCB layout at this point. I also decided that we should put
            more emphasis in segregating the analog and digital portions of the PCB. Hence, we redid the placement of
            components and the routing (to Matthew’s chagrin). Matthew placed and routed components for another 15 hours.
            Once he was done, I simply cleaned up some of the tracks, vias, adjusted track widths, and modified the
            silkscreen. After fall break (and before our design review), we are planning to populate and test the HBmS.

            <p></p>
            <img src="Team/progress/sbhatta/img/week7/DAqS.png" width="100%" /></img>
            <figcaption>Fig. 16: Schematic of the Data Acquisition System (DAqS) [V1.0].</figcaption>
            <br />

            <!-- Week 9 -->
            <h4>Week 9:</h4>
            <b>Date:</b> 10/22/2021<br />
            <b>Total hours:</b> 5 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I debugged the HBmS PCB (our debugging setup is shown in Fig. 17). The PCB had one major problem:
            the LiPo charging circuit was not working as intended; the LiPo charger IC was keeping the battery isolated
            from the rest of the board unless I momentarily (manually) pulled the VDD pin of the IC high during startup.
            I believe that the charging chip is intended for more of a power source backup scenario; hence, the IC might
            need the primary source (USB power for example) to be present at startup before it can switch over to battery
            supply. This issue was particularly vexing because it was not mentioned in the datasheet. We are using an external
            battery-charging module as a workout for debugging and characterization. This module works well and should be simple
            to reverse-engineer into our design (perhaps as a patch). To keep with our timeline, we might implement quick fixes
            by jumping wires and adding a patch (and send out a final iteration after we debug our other board). All other HBmS
            systems are working nominally, and we are looking to do a full numerical characterization this weekend. The energy
            harvesting circuit is producing some haptic feedback, which will be measurable with our test setup but might not be
            noticeable by the user. When we do our characterization test, it will be interesting to see how the haptic energy
            harvesting and haptic feedback circuits interact in terms of net power draw/generation and net braking.

            <p></p>
            <img src="Team/progress/sbhatta/img/week9/Debugging.png" width="60%" /></img>
            <figcaption>Fig. 17: HBmS debugging setup.</figcaption>
            <br />

            <!-- Week 10 -->
            <h4>Week 10:</h4>
            <b>Date:</b> 10/29/2021<br />
            <b>Total hours:</b> 15 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I did the “legal analysis.” In terms of design work, I found a suitable single-cell LiPo charging chip
            and patched it to the HBmS V1 PCB (see Fig. 18). There were a few changes with the energy harvesting circuit: we
            now dump the current from our boost converter to the input of our buck converter via a resistor and diode since our
            new LiPo charging chip takes a long time to initiate the charging process (compared to the on-time of the boost
            converter as the motor shaft is moving). In this way, we use our harvested energy almost immediately, not storing
            it in the battery. We did a full integration test and found that the HBmS was self-powering below ~10% relay duty
            cycle (we think we can do better). Overall, the HBmS draws below 2 mW. Fig. 19 shows the large vibrations created
            by our system and Fig. 20 shows the mean viscous coefficient vs. relay duty cycle. Unfortunately, we found out that
            nothing really worked anymore just as we were about to proudly demo our system on Wednesday. After four hours of
            debugging and testing several hypotheses, we found out that we had left large pools of flux residue on our board overnight,
            which had absorbed moisture and had started shorting the fine-pitched pins of our JST connector (we were measuring ~80 Ohm
            between adjacent pins). After rinsing our board properly (courtesy of Joe), everything started working again (we still measure
            ~100 KOhm between adjacent pins). We recollected the system integration data since we do not know how each subsystem was affected
            by the residue. The things that I am planning to accomplish this weekend are: (1) soldering the DAqS (2) plotting new HBmS data (3)
            updating the HBmS schematic/layout and ordering the updated board (4) soldering and testing the potentiometer board.
            <p></p>
            <img src="Team/progress/sbhatta/img/week10/Patch.png" width="60%" /></img>
            <figcaption>Fig. 18: Backside of HBmS V1 with patch visible.</figcaption>
            <br />
            <p></p>
            <img src="Team/progress/sbhatta/img/week10/Acceleration.png" width="60%" /></img>
            <figcaption>Fig. 19: Visualization of the linear acceleration generated by our haptic feedback system on a 500 g mass (as inferred from a rotary encoder).</figcaption>
            <br />
            <p></p>
            <img src="Team/progress/sbhatta/img/week10/Duty.png" width="60%" /></img>
            <figcaption>Fig. 20: Terminal velocity and viscous coefficient vs. duty cycle; nonlinearity is hypothesized to be caused by rotor slippage.</figcaption>
            <br />

            <!-- Week 11 -->
            <h4>Week 11:</h4>
            <b>Date:</b> 11/04/2021<br />
            <b>Total hours:</b> 18 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I soldered the DAqS board with assistance from Matthew. Our full-system integration test setup is shown in Fig. 21.
            <p></p>
            <img src="Team/progress/sbhatta/img/week11/Setup.png" width="40%" /></img>
            <figcaption>Fig. 21: Full system integration test setup.</figcaption>
            <br />
            Testing of the DAqS board is ongoing. Currently, we know we can do the following with our board: (1) program our MCU (2) output a PWM signal to generate haptic feedback (3) generate significant motion interrupt pulses with the analog event detector and (4) communicate with our IMU. For some time, we were not able to communicate with our IMU at all, so we took it for an x-ray (see Fig. 22).
            <p></p>
            <img src="Team/progress/sbhatta/img/week11/Xray.png" width="50%" /></img>
            <figcaption>Fig. 22: X-ray of our PCB around the IMU chip.</figcaption>
            <br />
            From the x-ray it looked like our chip was soldered correctly. We realized that the issue lay not with the solder joints but rather the code (see Isaac’s progress report), and we promptly resolved the issue. Our previous analog potentiometer ended up having strange discrete segments not shown on the datasheet (we found this out on Saturday). We have resolved our potentiometer issue quickly with a new potentiometer and board (see Fig. 23).
            <p></p>
            <img src="Team/progress/sbhatta/img/week11/Pot.png" width="50%" /></img>
            <figcaption>Fig. 23: Potentiometer board.</figcaption>
            <br />
            We are looking to continue integration tests and get our Bluetooth and ADC working. I have ordered a new HBmS board (it should arrive sometime next week) that should resolve the fly wiring that we had to do with the LiPo charging circuit on the first version. The schematic of the new HBmS board is shown in Fig. 24.
            <p></p>
            <img src="Team/progress/sbhatta/img/week11/HBmS.png" width="100%" /></img>
            <figcaption>Fig. 24: HBmS V2 schematic.</figcaption>
            <br />

            <!-- Week 12 -->
            <h4>Week 12:</h4>
            <b>Date:</b> 11/12/2021<br />
            <b>Total hours:</b> 8 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I soldered HBmS V2 and did preliminary tests on HBmS V2 (see Fig. 25). All systems are working as expected on HBmS V2
            with no fly-wiring! This means HBmS V2 can (1) charge our lipo-battery while our main switch is on or off (with charging status indication)
            (2) deliver haptic feedback by shorting motor coils (3) use back-emf to turn-on a boost converter, offsetting device power draw and (4) generate
            2.5 V for the LDO inputs on the DAqS. So far, the DAqS has not shown major issues, although integration tests are ongoing (Fig. 26 shows our current integration testing setup).
            <p></p>
            <img src="Team/progress/sbhatta/img/week12/HBmS.png" width="50%" /></img>
            <figcaption>Fig. 25: HBmS V2 with battery charging.</figcaption>
            <br />
            <p></p>
            <img src="Team/progress/sbhatta/img/week12/Setup.png" width="50%" /></img>
            <figcaption>Fig. 26: Current integration test setup.</figcaption>
            <br />

            <!-- Week 13 -->
            <h4>Week 13:</h4>
            <b>Date:</b> 11/18/2021<br />
            <b>Total hours:</b> 9 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I helped Matthew with some administrative tasks (he was ill) such as getting our fifth PSSC changed. Otherwise, I spent the rest of the time helping out Isaac with his embedded integration tasks. In particular, we worked toward completion of PSSC 3 and 5. Fig. 27 shows our current integration testing setup. I also started the patent application process.

            <p></p>
            <img src="Team/progress/sbhatta/img/week13/Setup.png" width="50%" /></img>
            <figcaption>Fig. 27: Current integration test setup.</figcaption>
            <br />

            <!-- Week 14 -->
            <h4>Week 14:</h4>
            <b>Date:</b> 11/28/2021<br />
            <b>Total hours:</b> 2 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I helped mount the electronics in the final mechanical mount. The final packaged device is shown in Fig. 28. We did some preliminary tests with haptic feedback. We were able to sense the haptic feedback on our skin, but the sensation was not very strong. We will have to do more comprehensive testing, seeing the effect of different PWM duty cycles and frequencies on haptic feedback sensation.

            <p></p>
            <img src="Team/progress/sbhatta/img/week14/Final.jpg" width="50%" /></img>
            <figcaption>Fig. 28: Final packaged device.</figcaption>
            <br />

            <!-- Week 15 -->
            <h4>Week 15:</h4>
            <b>Date:</b> 12/03/2021<br />
            <b>Total hours:</b> 4 hours<br />
            <b>Description of design efforts:</b><br />
            This week, I helped write the final senior design report. To make Isaac's code function as expected (i.e. be able to use the analog event detector to determine when to go to sleep) I increased the sensitivity of the analog event detector by increasing the gain of the highpass filter. However, this was shown to result in false positives. Hence, we are waking up using the analog event detector and going to sleep using a software activity detector. Fig. 29 shows the current state of development of the wearable. 

            <p></p>
            <img src="Team/progress/sbhatta/img/week15/Final.jpg" width="50%" /></img>
            <figcaption>Fig. 29: Ongoing development on the final packaged device. Note the cool new elastic bands.</figcaption>
            <br />

        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
